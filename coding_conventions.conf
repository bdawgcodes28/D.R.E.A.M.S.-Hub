D.R.E.A.M.S. Hub Coding Conventions

Purpose
- Establish consistent, readable, and maintainable code across all apps (admin, client, server).
- Keep code simple, explicit, and well-documented.

Project Structure & Modularity
- Create dedicated files/modules for distinct domains and features (e.g., users, curriculums, events).
- Co-locate related code (components, hooks, styles, tests) when it improves discoverability.
- Separate concerns: routing, controllers/handlers, services, data-access, and utilities.
- Avoid god files. Prefer multiple small, focused modules over one large file.

Readability & Simplicity
- Prefer clear, straightforward implementations over cleverness.
- Avoid unnecessary complexity; refactor long functions (>50 lines) into smaller units.
- Use meaningful names for variables, functions, and files (full words over abbreviations).
- Keep expressions simple; break complex conditions into well-named booleans.

Alignment & Formatting
- Strive for visually symmetric alignment where it improves clarity, but never at the cost of diffs or editor tooling.
- Follow the repo’s ESLint configuration. If Prettier is used, don’t hand-format around it.
- One statement per line. Avoid deep nesting beyond 2–3 levels; use early returns.

Comments & Documentation
- Comment “why”, not “what”. Code should explain the “what”.
- Document non-obvious decisions, edge cases, and constraints.
- Provide JSDoc/TSdoc (or concise block comments) for complex functions and modules.
- Add a file header for new files using this template:

  /**
   * @author  Your Name
   * @date    YYYY-MM-DD
   * @description Short description of this file’s purpose and responsibilities.
   */

Error Handling & Logging
- Fail fast with helpful error messages; validate inputs at boundaries.
- Prefer try/catch around external boundaries (I/O, network, DB), not every line of code.
- Log actionable information (who/what/when/context); avoid logging secrets.
- Use consistent error shapes in APIs (status, code, message, details).

JavaScript/TypeScript
- Prefer TypeScript when practical; if JS, use JSDoc for types in complex areas.
- Use const by default; let when variables need reassignment; avoid var.
- Prefer async/await over raw Promises; handle rejections explicitly.
- Avoid mutation; prefer pure functions and immutable data patterns.

Imports & Exports
- Group imports: stdlib/node, third-party, internal. Separate groups with a blank line.
- Use named exports over default when possible for clarity and refactoring safety.

React (Vite apps)
- File per component; name components in PascalCase (e.g., UserCard.jsx/tsx).
- Keep components focused; extract hooks for shared logic.
- Derive UI from props/state; avoid side effects in render.
- Use controlled components for forms; validate inputs.
- Memoize carefully (React.memo, useMemo, useCallback) for proven performance issues.

Node/Express Servers
- Separate routes, controllers, services, and data-access.
- Validate request payloads (e.g., zod, joi) at the edge.
- Sanitize and normalize inputs; set sensible limits (body size, timeouts).
- Use environment variables via a single configuration module; validate on startup.

Security
- Never log secrets or store them in the repo. Use .env and secret managers where possible.
- Sanitize user input; prevent injection (SQL/NoSQL/Command) and XSS.
- Enable CORS only as needed; use HTTPS in production.
- Keep dependencies updated; address critical vulnerabilities promptly.

Performance
- Avoid premature optimization; measure first.
- Batch network/DB calls where possible; cache hot paths (
  in-memory, HTTP caching, or CDN) when appropriate.

Testing
- Write unit tests for core logic and critical paths.
- Favor integration tests for routes/APIs and key flows.
- Keep tests deterministic; use factories/builders over fixtures when practical.

Git & Reviews
- Small, focused commits with descriptive messages (imperative mood: "Add X", "Fix Y").
- Branch per feature/fix. Keep PRs small and reviewable with context in the description.
- Address review feedback promptly; follow conventions unless there’s a strong reason not to.

Code Style Summary
- Meaningful names; avoid abbreviations.
- Early returns; shallow nesting.
- One responsibility per function/module.
- Purposeful comments and consistent file headers.
- Domain-based file organization; avoid monolith files.

Examples
Alignment (use sparingly to improve readability):
  const MAX_RETRY_COUNT   = 3;
  const defaultTimeoutMs  = 15_000;
  const connectionLabel   = "primary";

Clear boolean extraction:
  const hasValidToken = Boolean(token) && !isExpired(token);
  if (!hasValidToken) return res.status(401).json({ message: "Unauthorized" });

File Header Example:
  /**
   * @author  Elias Lopes
   * @date    2025-09-16
   * @description Express server entrypoint that configures routes and middleware.
   */


